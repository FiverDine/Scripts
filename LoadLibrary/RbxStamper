local a={}function PlaneIntersection(b)local c=false;local d=game:GetService("Workspace").CurrentCamera;local e=Vector3.new(d.CoordinateFrame.p.X,d.CoordinateFrame.p.Y,d.CoordinateFrame.p.Z)local f=Vector3.new(b.X,b.Y,b.Z)local g=Vector3.new(0,1,0)local h=Vector3.new(0,0,0)local i=g:Dot(f-e)local j=b;if i~=0 then local a=g:Dot(h-e)/i;if a>=0 and a<=1 then local k=(f-e)*a+e;j=game:GetService("Workspace").Terrain:WorldToCell(k)c=true end end;return j,c end;function GetTerrainForMouse(l)local m=game:GetService("Workspace").Terrain:WorldToCellPreferSolid(Vector3.new(l.hit.x,l.hit.y,l.hit.z))local n=nil;local c=nil;if 0==game:GetService("Workspace").Terrain:GetCell(m.X,m.Y,m.Z).Value then m=nil;n,c=PlaneIntersection(Vector3.new(l.hit.x,l.hit.y,l.hit.z))if c then m=n end end;return m end;local o=Vector3.new(.3,.3,.3)local function p(q,r,s)if q:IsA("BasePart")then q.CFrame=r*(q.CFrame-s)+s end;local t=q:GetChildren()for u=1,#t do p(t[u],r,s)end end;local function v(w,x)local r=CFrame.Angles(0,x,0)local s=w:GetModelCFrame().p;p(w,r,s)end;local function y(z,A,B,C)if z:IsA("BasePart")then A[#A+1]=z elseif z:IsA("Script")then B[#B+1]=z elseif z:IsA("Decal")then C[#C+1]=z end;for D,E in pairs(z:GetChildren())do y(E,A,B,C)end end;local function F(G,H)local I=game:GetService("Workspace"):FindFirstChild("Terrain")local J=I:WorldToCell(G)local K=I:WorldToCell(H)local L=J.X;local M=J.Y;local N=J.Z;local O=K.X;local P=K.Y;local Q=K.Z;if L<I.MaxExtents.Min.X then L=I.MaxExtents.Min.X end;if M<I.MaxExtents.Min.Y then M=I.MaxExtents.Min.Y end;if N<I.MaxExtents.Min.Z then N=I.MaxExtents.Min.Z end;if O>I.MaxExtents.Max.X then O=I.MaxExtents.Max.X end;if P>I.MaxExtents.Max.Y then P=I.MaxExtents.Max.Y end;if Q>I.MaxExtents.Max.Z then Q=I.MaxExtents.Max.Z end;for R=L,O do for S=M,P do for T=N,Q do if I:GetCell(R,S,T).Value>0 then return true end end end end;return false end;local function U(V,W)if not V then return end;if V.className=="Seat"or V.className=="VehicleSeat"then table.insert(W,V)end;local X=V:GetChildren()for Y=1,#X do U(X[Y],W)end end;local function Z(w,_)local a0={}U(w,a0)if _ then for a1=1,#a0 do local a2=a0[a1]:FindFirstChild("SeatWeld")while a2 do a2:Remove()a2=a0[a1]:FindFirstChild("SeatWeld")end end else for a1=1,#a0 do local a3=Instance.new("Weld")a3.Name="SeatWeld"a3.Parent=a0[a1]end end end;local function a4(a5)local a6=a5:FindFirstChild("AutoAlignToFace")if a6 then return a6.Value else return false end end;local function a7(a8)local a9=Vector3.new(1,0,0)local aa=Vector3.new(0,1,0)local ab=Vector3.new(0,0,1)local ac=a8.x*a9.x+a8.y*a9.y+a8.z*a9.z;local ad=a8.x*aa.x+a8.y*aa.y+a8.z*aa.z;local ae=a8.x*ab.x+a8.y*ab.y+a8.z*ab.z;if math.abs(ac)>math.abs(ad)and math.abs(ac)>math.abs(ae)then if ac>0 then return 0 else return 3 end elseif math.abs(ad)>math.abs(ac)and math.abs(ad)>math.abs(ae)then if ad>0 then return 1 else return 4 end else if ae>0 then return 2 else return 5 end end end;local function af(ag,ah)local ai=nil;if not ah then return ah end;if ah and(ah:IsA("Model")or ah:IsA("Tool"))then ai=ah:GetModelCFrame()ah:TranslateBy(ag.p-ai.p)else ah.CFrame=ag end;return ah end;local function aj(ak,al,am)if math.abs(al)<.01 then return 0 end;return(am-ak)/al end;local function an(ao,ak,ap)if not ao then return 0 end;local aq=nil;local ar=nil;if ao:IsA("Model")then aq=ao:GetModelCFrame()ar=ao:GetModelSize()else aq=ao.CFrame;ar=ao.Size end;local as=aq:pointToObjectSpace(ak)local at=aq:pointToObjectSpace(ap)local au=at-as;local av=1;local aw=1;local ax=1;if au.X>0 then av=-1 end;if au.Y>0 then aw=-1 end;if au.Z>0 then ax=-1 end;local ay=aj(as.X,au.X,ar.X/2*av)local az=aj(as.Y,au.Y,ar.Y/2*aw)local aA=aj(as.Z,au.Z,ar.Z/2*ax)local aB=0;if ay>az then if ay>aA then aB=1*av else aB=3*ax end else if az>aA then aB=2*aw else aB=3*ax end end;return aB end;local function aC(ao)local aD=Vector3.new(math.huge,math.huge,math.huge)local aE=Vector3.new(-math.huge,-math.huge,-math.huge)if ao:IsA("Terrain")then aD=Vector3.new(-2,-2,-2)aE=Vector3.new(2,2,2)elseif ao:IsA("BasePart")then aD=-0.5*ao.Size;aE=-aD else aE=ao:GetModelSize()*0.5;aD=-aE end;local aF=ao:FindFirstChild("Justification")if aF~=nil then local aG=aF.Value;local aH=Vector3.new(2,2,2)local aI=aE-aD-Vector3.new(0.01,0.01,0.01)local aJ=Vector3.new(4*math.ceil(aI.x/4),4*math.ceil(aI.y/4),4*math.ceil(aI.z/4))local aK=aJ-aI;aD=aD-0.5*aK*aG;aE=aE+0.5*aK*(aH-aG)end;return aD,aE end;local function aL(ao)local aD=Vector3.new(math.huge,math.huge,math.huge)local aE=Vector3.new(-math.huge,-math.huge,-math.huge)if ao:IsA("BasePart")and not ao:IsA("Terrain")then local aM=ao.CFrame:pointToWorldSpace(-0.5*ao.Size)local aN=ao.CFrame:pointToWorldSpace(0.5*ao.Size)aD=Vector3.new(math.min(aM.X,aN.X),math.min(aM.Y,aN.Y),math.min(aM.Z,aN.Z))aE=Vector3.new(math.max(aM.X,aN.X),math.max(aM.Y,aN.Y),math.max(aM.Z,aN.Z))elseif ao:IsA("Terrain")then else local aM=ao:GetModelCFrame():pointToWorldSpace(-0.5*ao:GetModelSize())local aN=ao:GetModelCFrame():pointToWorldSpace(0.5*ao:GetModelSize())aD=Vector3.new(math.min(aM.X,aN.X),math.min(aM.Y,aN.Y),math.min(aM.Z,aN.Z))aE=Vector3.new(math.max(aM.X,aN.X),math.max(aM.Y,aN.Y),math.max(aM.Z,aN.Z))end;return aD,aE end;local function aO(aP)if aP.Parent:FindFirstChild("RobloxModel")~=nil then return aC(aP.Parent)else return aC(aP)end end;local function aQ(aP)if aP.Parent:FindFirstChild("RobloxModel")~=nil then if aP.Parent:IsA("Tool")then return aP.Parent.Handle.CFrame else return aP.Parent:GetModelCFrame()end else return aP.CFrame end end;local function aR(q)if not q then return false end;if not q.Parent then return false end;if q:FindFirstChild("Humanoid")then return false end;if q:FindFirstChild("RobloxStamper")or q:FindFirstChild("RobloxModel")then return true end;if q:IsA("Part")and not q.CanCollide then return false end;if q==game:GetService("Lighting")then return false end;return aR(q.Parent)end;local function aS(aT,aU,aV)local aW=game:GetService("Workspace"):FindPartsInRegion3(Region3.new(Vector3.new(aT.Position.X,aU,aT.Position.Z)-Vector3.new(.75,2.75,.75),Vector3.new(aT.Position.X,aU,aT.Position.Z)+Vector3.new(.75,1.75,.75)),aT.Parent,100)for Y=1,#aW do if aW[Y].CanCollide and not aW[Y]:IsDescendantOf(aV.CurrentParts)then return false end end;if F(Vector3.new(aT.Position.X,aU,aT.Position.Z)-Vector3.new(.75,2.75,.75),Vector3.new(aT.Position.X,aU,aT.Position.Z)+Vector3.new(.75,1.75,.75))then return false end;return true end;local function aX(aY,aV)if not aY then return nil end;if not aV then error("findConfigAtMouseTarget: stampData is nil")return nil end;if not aV["CurrentParts"]then return nil end;local aZ=4.0;local a_=false;local b0=CFrame.new(0,0,0)local b1,b2=aC(aV.CurrentParts)local b3=b2-b1;local ai;if aV.CurrentParts:IsA("Model")or aV.CurrentParts:IsA("Tool")then ai=aV.CurrentParts:GetModelCFrame()else ai=aV.CurrentParts.CFrame end;if aY then if aV.CurrentParts:IsA("Tool")then aY.TargetFilter=aV.CurrentParts.Handle else aY.TargetFilter=aV.CurrentParts end end;local b4=false;local aP=nil;local b5=pcall(function()aP=aY.Target end)if not b5 then return a_,b0 end;local b6=Vector3.new(0,0,0)if aY then b6=Vector3.new(aY.Hit.x,aY.Hit.y,aY.Hit.z)end;local j=nil;if nil==aP then j=GetTerrainForMouse(aY)if nil==j then b4=false;return a_,b0 else aP=game:GetService("Workspace").Terrain;b4=true;j=Vector3.new(j.X-1,j.Y,j.Z)b6=game:GetService("Workspace").Terrain:CellCenterToWorld(j.x,j.y,j.z)end end;local b7,b8=aO(aP)local b9=b8-b7;local targetCFrame=aQ(aP)if aP:IsA("Terrain")then local I=game:GetService("Workspace"):FindFirstChild("Terrain")local ba=I:WorldToCellPreferSolid(b6)if b4 then ba=j end;targetCFrame=CFrame.new(game:GetService("Workspace").Terrain:CellCenterToWorld(ba.x,ba.y,ba.z))end;local bb=targetCFrame:pointToObjectSpace(b6)local bc=Vector3.new(0,0,0)if aY then bc=aP.CFrame:vectorToWorldSpace(Vector3.FromNormalId(aY.TargetSurface))end;local bd;local be;local bf;if a7(bc)==0 then bd=targetCFrame:vectorToObjectSpace(Vector3.new(1,-1,1))bf=ai:vectorToObjectSpace(Vector3.new(-1,-1,1))be=Vector3.new(0,1,1)elseif a7(bc)==3 then bd=targetCFrame:vectorToObjectSpace(Vector3.new(-1,-1,-1))bf=ai:vectorToObjectSpace(Vector3.new(1,-1,-1))be=Vector3.new(0,1,1)elseif a7(bc)==1 then bd=targetCFrame:vectorToObjectSpace(Vector3.new(-1,1,1))bf=ai:vectorToObjectSpace(Vector3.new(-1,-1,1))be=Vector3.new(1,0,1)elseif a7(bc)==4 then bd=targetCFrame:vectorToObjectSpace(Vector3.new(-1,-1,1))bf=ai:vectorToObjectSpace(Vector3.new(-1,1,1))be=Vector3.new(1,0,1)elseif a7(bc)==2 then bd=targetCFrame:vectorToObjectSpace(Vector3.new(-1,-1,1))bf=ai:vectorToObjectSpace(Vector3.new(-1,-1,-1))be=Vector3.new(1,1,0)else bd=targetCFrame:vectorToObjectSpace(Vector3.new(1,-1,-1))bf=ai:vectorToObjectSpace(Vector3.new(1,-1,1))be=Vector3.new(1,1,0)end;bd=bd*0.5*b9+0.5*(b8+b7)bf=bf*0.5*b3+0.5*(b2+b1)local bg=bb-bd;local bh=Vector3.new(aZ*math.modf(bg.x/aZ),aZ*math.modf(bg.y/aZ),aZ*math.modf(bg.z/aZ))bh=bh*be;local bi=bh+bd;local bj=targetCFrame:pointToWorldSpace(bi)local bk=ai:vectorToWorldSpace(bf)local bl=bj-bk;local R,S,T,bm,bn,bo,bp,bq,br,bs,bt,bu=ai:components()b0=CFrame.new(bl.x,bl.y,bl.z,bm,bn,bo,bp,bq,br,bs,bt,bu)a_=true;return a_,b0,a7(bc)end;local function bv(bw,bx)local by=math.abs(bw)local bz=math.abs(bx)local bA=math.sqrt(by*by+bz*bz)local bB=bz/bA;local bC=1;local bD=1;if bw<0 then bC=-1 end;if bx<0 then bD=-1 end;if bB>.382683432 then return.707106781*bA*bC,.707106781*bA*bD else return bA*bC,0 end end;local function bE(z,bF,bG)if z:IsA("ManualWeld")or z:IsA("Rotate")then table.insert(bF,z)table.insert(bG,z.Parent)else local bH=z:GetChildren()for a1=1,#bH do bE(bH[a1],bF,bG)end end end;local function bI(bF,bG)for a1=1,#bF do bF[a1].Parent=bG[a1]end end;a.CanEditRegion=function(ao,bJ)if not bJ then return true,false end;local b1,b2=aL(ao)if b1.X<bJ.CFrame.p.X-bJ.Size.X/2 or b1.Y<bJ.CFrame.p.Y-bJ.Size.Y/2 or b1.Z<bJ.CFrame.p.Z-bJ.Size.Z/2 then return false,false end;if b2.X>bJ.CFrame.p.X+bJ.Size.X/2 or b2.Y>bJ.CFrame.p.Y+bJ.Size.Y/2 or b2.Z>bJ.CFrame.p.Z+bJ.Size.Z/2 then return false,false end;return true,false end;a.GetStampModel=function(bK,bL,bM)if bK==0 then return nil,"No Asset"end;if bK<0 then return nil,"Negative Asset"end;local function bN(z)if z:IsA("BasePart")then z.Locked=false end;for D,E in pairs(z:GetChildren())do bN(E)end end;local function bO(bP)if bP==1 then return BrickColor.new("Bright green")elseif bP==2 then return BrickColor.new("Bright yellow")elseif bP==3 then return BrickColor.new("Bright red")elseif bP==4 then return BrickColor.new("Sand red")elseif bP==5 then return BrickColor.new("Black")elseif bP==6 then return BrickColor.new("Dark stone grey")elseif bP==7 then return BrickColor.new("Sand blue")elseif bP==8 then return BrickColor.new("Deep orange")elseif bP==9 then return BrickColor.new("Dark orange")elseif bP==10 then return BrickColor.new("Reddish brown")elseif bP==11 then return BrickColor.new("Light orange")elseif bP==12 then return BrickColor.new("Light stone grey")elseif bP==13 then return BrickColor.new("Sand green")elseif bP==14 then return BrickColor.new("Medium stone grey")elseif bP==15 then return BrickColor.new("Really red")elseif bP==16 then return BrickColor.new("Really blue")elseif bP==17 then return BrickColor.new("Bright blue")else return BrickColor.new("Bright green")end end;local function bQ(bR,bS,bT)local bU=nil;if bS==1 or bS==4 then bU=Instance.new("WedgePart")elseif bS==2 then bU=Instance.new("CornerWedgePart")else bU=Instance.new("Part")end;bU.Name="MegaClusterCube"bU.Size=Vector3.new(4,4,4)bU.BottomSurface="Smooth"bU.TopSurface="Smooth"bU.BrickColor=bO(bR)local bV=0;local bW=math.pi;if bS==4 then bV=-math.pi/2 end;if bS==2 or bS==3 then bW=0 end;bU.CFrame=CFrame.Angles(0,math.pi/2*bT+bW,bV)if bS==3 then local bX=Instance.new("SpecialMesh")bX.MeshType="FileMesh"bX.MeshId="https://www.roblox.com/asset/?id=66832495"bX.Scale=Vector3.new(2,2,2)bX.Parent=bU end;local bY=Instance.new("Vector3Value")bY.Value=Vector3.new(bR,bS,bT)bY.Name="ClusterMaterial"bY.Parent=bU;return bU end;local bZ;local b_;loading=true;if bM then b_=coroutine.create(function()bZ=game:GetService("InsertService"):LoadAssetVersion(bK)loading=false end)coroutine.resume(b_)else b_=coroutine.create(function()bZ=game:GetService("InsertService"):LoadAsset(bK)loading=false end)coroutine.resume(b_)end;local c0=0;local c1=0;local c2=8;while loading and c1<c2 do c0=tick()wait(1)c1=c1+tick()-c0 end;loading=false;if c1>=c2 then return nil,"Load Time Fail"end;if bZ==nil then return nil,"Load Asset Fail"end;if not bZ:IsA("Model")then return nil,"Load Type Fail"end;local c3=bZ:GetChildren()if#c3==0 then return nil,"Empty Model Fail"end;bN(bZ)bZ=bZ:GetChildren()[1]for c4,c5 in pairs(c3)do if c5:IsA("Team")then c5.Parent=game:GetService("Teams")elseif c5:IsA("Sky")then local c6=game:GetService("Lighting")for D,E in pairs(c6:GetChildren())do if E:IsA("Sky")then E:Remove()end end;c5.Parent=c6;return end end;if bZ:FindFirstChild("RobloxModel")==nil then local c7=Instance.new("BoolValue",bZ)c7.Name="RobloxModel"if bZ:FindFirstChild("RobloxStamper")==nil then local c8=Instance.new("BoolValue",bZ)c8.Name="RobloxStamper"end end;if bL then if bZ.Name=="MegaClusterCube"then if bL==6 then local c9=Instance.new("BoolValue")c9.Name="AutoWedge"c9.Parent=bZ else local ca=bZ:FindFirstChild("ClusterMaterial")if ca then if ca:IsA("Vector3Value")then bZ=bQ(ca.Value.X,bL,ca.Value.Z)else bZ=bQ(ca.Value,bL,0)end else bZ=bQ(1,bL,0)end end end end;return bZ end;a.SetupStamperDragger=function(cb,aY,cc,cd,ce)if not cb then error("SetupStamperDragger: modelToStamp (first arg) is nil!  Should be a stamper model")return nil end;if not cb:IsA("Model")and not cb:IsA("BasePart")then error("SetupStamperDragger: modelToStamp (first arg) is neither a Model or Part!")return nil end;if not aY then error("SetupStamperDragger: Mouse (second arg) is nil!  Should be a mouse object")return nil end;if not aY:IsA("Mouse")then error("SetupStamperDragger: Mouse (second arg) is not of type Mouse!")return nil end;local cf=nil;local cg=nil;local ch=nil;if cc then if not cc:IsA("Model")then error("SetupStamperDragger: StampInModel (optional third arg) is not of type 'Model'")return nil end;if not cd then error("SetupStamperDragger: AllowedStampRegion (optional fourth arg) is nil when StampInModel (optional third arg) is defined")return nil end;ch=ce;cf=cc;cg=cd end;local ci=0;local aV=nil;local cj=nil;local ck=Instance.new("SelectionBox")ck.Color=BrickColor.new("Bright red")ck.Transparency=0;ck.Archivable=false;local cl=Instance.new("Part")cl.Parent=nil;cl.Size=Vector3.new(4,4,4)cl.CFrame=CFrame.new()cl.Archivable=false;local cm=Instance.new("SelectionBox")cm.Color=BrickColor.new("Toothpaste")cm.Adornee=cl;cm.Visible=true;cm.Transparency=0;cm.Name="HighScalabilityStamperLine"cm.Archivable=false;local cn={}cn.Start=nil;cn.End=nil;cn.Adorn=cm;cn.AdornPart=cl;cn.InternalLine=nil;cn.NewHint=true;cn.MorePoints={nil,nil}cn.MoreLines={nil,nil}cn.Dimensions=1;local co={}local cp=false;local cq=false;local cr=false;local cs={}local ct=nil;local cu=Instance.new("BoolValue")cu.Archivable=false;cu.Value=false;local cv={}cv.TerrainOrientation=0;cv.CFrame=0;local cw={}cw.Material=1;cw.clusterType=0;cw.clusterOrientation=0;local function cx()if not aV then return false end;if not aV.CurrentParts then return false end;return aV.CurrentParts:FindFirstChild("ClusterMaterial",true)or aV.CurrentParts.Name=="MegaClusterCube"end;local function cy()local cz=aV.CurrentParts:FindFirstChild("MegaClusterCube")if not cz then if not aV.CurrentParts.Name=="MegaClusterCube"then return else cz=aV.CurrentParts end end;cn.End=cz.CFrame.p;local cA=nil;local cB=Vector3.new(0,0,0)local cC=Vector3.new(0,0,0)if cn.Dimensions==1 then cA=cn.End-cn.Start;if math.abs(cA.X)<math.abs(cA.Y)then if math.abs(cA.X)<math.abs(cA.Z)then local cD,cE;if math.abs(cA.Y)>math.abs(cA.Z)then cD,cE=bv(cA.Y,cA.Z)else cE,cD=bv(cA.Z,cA.Y)end;cA=Vector3.new(0,cD,cE)else local cD,cF=bv(cA.Y,cA.X)cA=Vector3.new(cF,cD,0)end else if math.abs(cA.Y)<math.abs(cA.Z)then local cF,cE;if math.abs(cA.X)>math.abs(cA.Z)then cF,cE=bv(cA.X,cA.Z)else cE,cF=bv(cA.Z,cA.X)end;cA=Vector3.new(cF,0,cE)else local cF,cD=bv(cA.X,cA.Y)cA=Vector3.new(cF,cD,0)end end;cn.InternalLine=cA elseif cn.Dimensions==2 then cA=cn.MoreLines[1]cB=cn.End-cn.MorePoints[1]cB=cB-cA.unit*cA.unit:Dot(cB)local cG=CFrame.new(cn.Start,cn.Start+cA)local cH=cG:vectorToWorldSpace(Vector3.new(0,1,0))local cI=cG:vectorToWorldSpace(Vector3.new(1,0,0))local cJ=cI:Dot(cB)local cK=cH:Dot(cB)if math.abs(cK)>math.abs(cJ)then cB=cB-cI*cJ else cB=cB-cH*cK end;cn.InternalLine=cB elseif cn.Dimensions==3 then cA=cn.MoreLines[1]cB=cn.MoreLines[2]cC=cn.End-cn.MorePoints[2]cC=cC-cA.unit*cA.unit:Dot(cC)cC=cC-cB.unit*cB.unit:Dot(cC)cn.InternalLine=cC end;local cG=CFrame.new(cn.Start,cn.Start+cA)if cn.Dimensions==1 then cn.AdornPart.Size=Vector3.new(4,4,cA.magnitude+4)cn.AdornPart.CFrame=cG+cG:vectorToWorldSpace(Vector3.new(2,2,2)-cn.AdornPart.Size/2)else local cL=cG:vectorToObjectSpace(cA+cB+cC)cn.AdornPart.Size=Vector3.new(4,4,4)+Vector3.new(math.abs(cL.X),math.abs(cL.Y),math.abs(cL.Z))cn.AdornPart.CFrame=cG+cG:vectorToWorldSpace(cL/2)end;local cM=nil;if game:GetService("Players")["LocalPlayer"]then cM=game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")if cM and cM:IsA("PlayerGui")then if cn.Dimensions==1 and cA.magnitude>3 then cn.Adorn.Parent=cM elseif cn.Dimensions>1 then cn.Adorn.Parent=cM end end end;if cM==nil then cM=game:GetService("CoreGui")if cn.Dimensions==1 and cA.magnitude>3 then cn.Adorn.Parent=cM elseif cn.Dimensions>1 then cn.Adorn.Parent=cM end end end;local function cN(aY)if not aY then error("Error: RbxStamper.DoStamperMouseMove: Mouse is nil")return end;if not aY:IsA("Mouse")then error("Error: RbxStamper.DoStamperMouseMove: Mouse is of type",aY.className,"should be of type Mouse")return end;if not aY.Target then local j=GetTerrainForMouse(aY)if nil==j then return end end;if not aV then return end;local configFound,targetCFrame,cO=aX(aY,aV)if not configFound then error("RbxStamper.DoStamperMouseMove No configFound, returning")return end;local cP=0;if a4(aV.CurrentParts)and cO~=1 and cO~=4 then if cO==3 then cP=0-ci+a4(aV.CurrentParts)elseif cO==0 then cP=2-ci+a4(aV.CurrentParts)elseif cO==5 then cP=3-ci+a4(aV.CurrentParts)elseif cO==2 then cP=1-ci+a4(aV.CurrentParts)end end;local cQ=math.pi/2;ci=ci+cP;if aV.CurrentParts:IsA("Model")or aV.CurrentParts:IsA("Tool")then v(aV.CurrentParts,cQ*cP)else aV.CurrentParts.CFrame=CFrame.fromEulerAnglesXYZ(0,cQ*cP,0)*aV.CurrentParts.CFrame end;local b1,b2=aL(aV.CurrentParts)local cR=nil;if aV.CurrentParts:IsA("Model")then cR=aV.CurrentParts:GetModelCFrame()else cR=aV.CurrentParts.CFrame end;b1=b1+targetCFrame.p-cR.p;b2=b2+targetCFrame.p-cR.p;if F(b1+o,b2-o)then if cv.CFrame then if aV.CurrentParts:FindFirstChild("ClusterMaterial",true)then local cS=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if cS:IsA("Vector3Value")then local cT=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if cT then cT=cS end end end end;return end;if cx()then local cU=game:GetService("Workspace").Terrain:WorldToCell(targetCFrame.p)local cV=game:GetService("Workspace").Terrain:CellCenterToWorld(cU.X,cU.Y,cU.Z)local R,S,T,bm,bn,bo,bp,bq,br,bs,bt,bu=targetCFrame:components()targetCFrame=CFrame.new(cV.X,cV.Y,cV.Z,bm,bn,bo,bp,bq,br,bs,bt,bu)end;af(targetCFrame,aV.CurrentParts)cv.CFrame=targetCFrame;if aV.CurrentParts:FindFirstChild("ClusterMaterial",true)then local cW=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if cW:IsA("Vector3Value")then cv.TerrainOrientation=cW.Value.Z end end;if aY and aY.Target and aY.Target.Parent then local cX=aY.Target:FindFirstChild("RobloxModel")if not cX then cX=aY.Target.Parent:FindFirstChild("RobloxModel")end;local cY=aV.CurrentParts:FindFirstChild("UnstampableFaces")if true then local cZ=""local c_=""if cX and cX.Parent:FindFirstChild("UnstampableFaces")then cZ=cX.Parent.UnstampableFaces.Value end;if cY then c_=cY.Value end;local aB=0;if cX then aB=an(cX.Parent,game:GetService("Workspace").CurrentCamera.CoordinateFrame.p,aY.Hit.p)end;for d0 in string.gmatch(cZ,"[^,]+")do if aB==tonumber(d0)then cr=true;game:GetService("JointsService"):ClearJoinAfterMoveJoints()return end end;aB=an(aV.CurrentParts,aY.Hit.p,game:GetService("Workspace").CurrentCamera.CoordinateFrame.p)for d0 in string.gmatch(c_,"[^,]+")do if aB==tonumber(d0)then cr=true;game:GetService("JointsService"):ClearJoinAfterMoveJoints()return end end end end;cr=false;game:GetService("JointsService"):SetJoinAfterMoveInstance(aV.CurrentParts)if not pcall(function()if aY and aY.Target and aY.Target.Parent:FindFirstChild("RobloxModel")==nil then return else return end end)then error("Error: RbxStamper.DoStamperMouseMove Mouse is nil on second check")game:GetService("JointsService"):ClearJoinAfterMoveJoints()aY=nil;return end;if aY and aY.Target and aY.Target.Parent:FindFirstChild("RobloxModel")==nil then game:GetService("JointsService"):SetJoinAfterMoveTarget(aY.Target)else game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)end;game:GetService("JointsService"):ShowPermissibleJoints()if cx()and cn and cn.Start then cy()end end;local function d1(d2,aY)if co and co["Paused"]then return end;d2=string.lower(d2)if d2=='r'and not a4(aV.CurrentParts)then ci=ci+1;local d3=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if d3 and d3:IsA("Vector3Value")then d3.Value=Vector3.new(d3.Value.X,d3.Value.Y,(d3.Value.Z+1)%4)end;local cQ=math.pi/2;if aV.CurrentParts:IsA("Model")or aV.CurrentParts:IsA("Tool")then v(aV.CurrentParts,cQ)else aV.CurrentParts.CFrame=CFrame.fromEulerAnglesXYZ(0,cQ,0)*aV.CurrentParts.CFrame end;configFound,targetCFrame=aX(aY,aV)if configFound then af(targetCFrame,aV.CurrentParts)cN(aY)end elseif d2=='c'then if cn.InternalLine and cn.InternalLine.magnitude>0 and cn.Dimensions<3 then cn.MorePoints[cn.Dimensions]=cn.End;cn.MoreLines[cn.Dimensions]=cn.InternalLine;cn.Dimensions=cn.Dimensions+1;cn.NewHint=true end end end;ct=aY.KeyDown:connect(function(d2)d1(d2,aY)end)local function d4()if cn then cn.Start=nil;cn.End=nil;cn.InternalLine=nil;cn.NewHint=true end end;local function d5()local cM=game:GetService("CoreGui")if game:GetService("Players")then if game:GetService("Players")["LocalPlayer"]then if game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")then cM=game:GetService("Players").LocalPlayer.PlayerGui end end end;if not aV["ErrorBox"]then return end;aV.ErrorBox.Parent=cM;if aV.CurrentParts:IsA("Tool")then aV.ErrorBox.Adornee=aV.CurrentParts.Handle else aV.ErrorBox.Adornee=aV.CurrentParts end;delay(0,function()for a1=1,3 do if aV["ErrorBox"]then aV.ErrorBox.Visible=true end;wait(0.13)if aV["ErrorBox"]then aV.ErrorBox.Visible=false end;wait(0.13)end;if aV["ErrorBox"]then aV.ErrorBox.Adornee=nil;aV.ErrorBox.Parent=nil end end)end;local function d6(aY)if not aY then error("Error: RbxStamper.DoStamperMouseDown: Mouse is nil")return end;if not aY:IsA("Mouse")then error("Error: RbxStamper.DoStamperMouseDown: Mouse is of type",aY.className,"should be of type Mouse")return end;if not aV then return end;if cx()then if aY and cn then local cz=aV.CurrentParts:FindFirstChild("MegaClusterCube",true)local d7=game:GetService("Workspace").Terrain;if cz then cn.Dimensions=1;local d8=d7:WorldToCell(cz.CFrame.p)cn.Start=d7:CellCenterToWorld(d8.X,d8.Y,d8.Z)return else cn.Dimensions=1;local d8=d7:WorldToCell(aV.CurrentParts.CFrame.p)cn.Start=d7:CellCenterToWorld(d8.X,d8.Y,d8.Z)return end end end end;local function d9(q,da)q.TopSurface=da[1]q.BottomSurface=da[2]q.LeftSurface=da[3]q.RightSurface=da[4]q.FrontSurface=da[5]q.BackSurface=da[6]end;local function db(q,dc)local dd={}dd[1]=q.TopSurface;dd[2]=q.BottomSurface;dd[3]=q.LeftSurface;dd[4]=q.RightSurface;dd[5]=q.FrontSurface;dd[6]=q.BackSurface;dc[q]=dd end;local function de(q,df)end;local function dg(w)if not w then return nil end;local dh=0.7;local di=1;local dj=w:Clone()local B={}local a5={}local C={}aV={}aV.DisabledScripts={}aV.TransparencyTable={}aV.MaterialTable={}aV.CanCollideTable={}aV.AnchoredTable={}aV.ArchivableTable={}aV.DecalTransparencyTable={}aV.SurfaceTypeTable={}y(dj,a5,B,C)if#a5<=0 then return nil,"no parts found in modelToStamp"end;for D,dk in pairs(B)do if not dk.Disabled then dk.Disabled=true;aV.DisabledScripts[#aV.DisabledScripts+1]=dk end end;for D,q in pairs(a5)do aV.TransparencyTable[q]=q.Transparency;q.Transparency=di+(1-di)*q.Transparency;aV.MaterialTable[q]=q.Material;q.Material=Enum.Material.Plastic;aV.CanCollideTable[q]=q.CanCollide;q.CanCollide=false;aV.AnchoredTable[q]=q.Anchored;q.Anchored=true;aV.ArchivableTable[q]=q.Archivable;q.Archivable=false;db(q,aV.SurfaceTypeTable)local dl=0.5;local dm=0.5;delay(0,function()wait(dl)local dn=tick()local dp=dn;while dp-dn<dm and q and q:IsA("BasePart")and q.Transparency>dh do local dq=1-(dp-dn)/dm*(di-dh)if aV["TransparencyTable"]and aV.TransparencyTable[q]then q.Transparency=dq+(1-dq)*aV.TransparencyTable[q]end;wait(0.03)dp=tick()end;if q and q:IsA("BasePart")then if aV["TransparencyTable"]and aV.TransparencyTable[q]then q.Transparency=dh+(1-dh)*aV.TransparencyTable[q]end end end)end;for D,dr in pairs(C)do aV.DecalTransparencyTable[dr]=dr.Transparency;dr.Transparency=dh+(1-dh)*dr.Transparency end;Z(dj,true)Z(dj,false)aV.CurrentParts=dj;if a4(dj)then aV.CurrentParts:ResetOrientationToIdentity()ci=0 else local cQ=ci*math.pi/2;if aV.CurrentParts:IsA("Model")or aV.CurrentParts:IsA("Tool")then v(aV.CurrentParts,cQ)else aV.CurrentParts.CFrame=CFrame.fromEulerAnglesXYZ(0,cQ,0)*aV.CurrentParts.CFrame end end;local ds=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if ds and ds:IsA("Vector3Value")then ds.Value=Vector3.new(ds.Value.X,ds.Value.Y,(ds.Value.Z+ci)%4)end;local configFound,targetCFrame=aX(aY,aV)if configFound then aV.CurrentParts=af(targetCFrame,aV.CurrentParts)end;game:GetService("JointsService"):SetJoinAfterMoveInstance(aV.CurrentParts)return dj,a5 end;local function dt(j,du)local dv=game:GetService("Workspace").Terrain.CellCenterToWorld;local dw=dv(game:GetService("Workspace").Terrain,j.X,j.Y,j.Z)local dx=game:GetService("Workspace"):FindPartsInRegion3(Region3.new(dw-Vector3.new(2,2,2)+o,dw+Vector3.new(2,2,2)-o),aV.CurrentParts,100)local dy=false;for dz=1,#dx do if aR(dx[dz])then dy=true;break end end;if not dy then local dA={}for dz=1,#dx do if dx[dz].Parent and not dA[dx[dz].Parent]and dx[dz].Parent:FindFirstChild("Humanoid")and dx[dz].Parent:FindFirstChild("Humanoid"):IsA("Humanoid")then local dB=dx[dz].Parent:FindFirstChild("Torso")dA[dx[dz].Parent]=true;if dB then local cD=dw.Y+5;if aS(dB,cD,aV)then dB.CFrame=dB.CFrame+Vector3.new(0,cD-dB.CFrame.p.Y,0)else dy=true;break end end end end end;if not dy then local dC=true;if du then if cg then local j=dv(game:GetService("Workspace").Terrain,j.X,j.Y,j.Z)if j.X+2>cg.CFrame.p.X+cg.Size.X/2 then dC=false elseif j.X-2<cg.CFrame.p.X-cg.Size.X/2 then dC=false elseif j.Y+2>cg.CFrame.p.Y+cg.Size.Y/2 then dC=false elseif j.Y-2<cg.CFrame.p.Y-cg.Size.Y/2 then dC=false elseif j.Z+2>cg.CFrame.p.Z+cg.Size.Z/2 then dC=false elseif j.Z-2<cg.CFrame.p.Z-cg.Size.Z/2 then dC=false end end end;return dC end;return false end;local function dD(du)local dE=false;local dF=game:GetService("Workspace").Terrain;local cA=cn.InternalLine;local dG=game:GetService("Workspace").Terrain.MaxExtents.Max;local dH=game:GetService("Workspace").Terrain.MaxExtents.Min;local ds=1;local dI=0;local dJ=0;local dK=false;if aV.CurrentParts:FindFirstChild("AutoWedge")then dK=true end;if aV.CurrentParts:FindFirstChild("ClusterMaterial",true)then ds=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)if ds:IsA("Vector3Value")then dI=ds.Value.Y;dJ=ds.Value.Z;ds=ds.Value.X elseif ds:IsA("IntValue")then ds=ds.Value end end;if cn.Adorn.Parent and cn.Start and(cn.Dimensions>1 or cA and cA.magnitude>0)then local J=game:GetService("Workspace").Terrain:WorldToCell(cn.Start)local dL={0,0,0}local dM={0,0,0}local dN={0,0,0}local I=game:GetService("Workspace").Terrain;local dO={nil,nil,nil}local dP={Vector3.new(0,0,0),Vector3.new(0,0,0),Vector3.new(0,0,0)}local dQ={Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)}local dR={}if cn.Dimensions>1 then table.insert(dR,cn.MoreLines[1])end;if cA and cA.magnitude>0 then table.insert(dR,cA)end;if cn.Dimensions>2 then table.insert(dR,cn.MoreLines[2])end;for a1=1,#dR do dR[a1]=Vector3.new(math.floor(dR[a1].X+.5),math.floor(dR[a1].Y+.5),math.floor(dR[a1].Z+.5))if dR[a1].X>0 then dL[a1]=1 elseif dR[a1].X<0 then dL[a1]=-1 end;if dR[a1].Y>0 then dM[a1]=1 elseif dR[a1].Y<0 then dM[a1]=-1 end;if dR[a1].Z>0 then dN[a1]=1 elseif dR[a1].Z<0 then dN[a1]=-1 end;dO[a1]=Vector3.new(dL[a1],dM[a1],dN[a1])if dO[a1].magnitude<.9 then dO[a1]=nil end end;if not dR[2]then dR[2]=Vector3.new(0,0,0)end;if not dR[3]then dR[3]=Vector3.new(0,0,0)end;local dS=aV.CurrentParts:FindFirstChild("WaterForceTag",true)local dT=aV.CurrentParts:FindFirstChild("WaterForceDirectionTag",true)while dP[3].magnitude*4<=dR[3].magnitude do local dU=1;while dU<4 do dP[2]=Vector3.new(0,0,0)while dP[2].magnitude*4<=dR[2].magnitude do local dV=1;while dV<4 do dP[1]=Vector3.new(0,0,0)while dP[1].magnitude*4<=dR[1].magnitude do local dW=dP[1]+dP[2]+dP[3]local j=Vector3int16.new(J.X+dW.X,J.Y+dW.Y,J.Z+dW.Z)if j.X>=dH.X and j.Y>=dH.Y and j.Z>=dH.Z and j.X<dG.X and j.Y<dG.Y and j.Z<dG.Z then local dX=dt(j,du)if dX then if dS then I:SetWaterCell(j.X,j.Y,j.Z,Enum.WaterForce[dS.Value],Enum.WaterDirection[dT.Value])else I:SetCell(j.X,j.Y,j.Z,ds,dI,dJ)end;dE=true;if dK then game:GetService("Workspace").Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(j.x-1,j.y-1,j.z-1),Vector3int16.new(j.x+1,j.y+1,j.z+1)))end end end;dP[1]=dP[1]+dO[1]end;if dO[2]then while dV<4 and dQ[dV]:Dot(dO[2])==0 do dV=dV+1 end;if dV<4 then dP[2]=dP[2]+dQ[dV]*dQ[dV]:Dot(dO[2])end;dV=dV+1 else dP[2]=Vector3.new(1,0,0)dV=4 end;if dP[2].magnitude*4>dR[2].magnitude then dV=4 end end end;if dO[3]then while dU<4 and dQ[dU]:Dot(dO[3])==0 do dU=dU+1 end;if dU<4 then dP[3]=dP[3]+dQ[dU]*dQ[dU]:Dot(dO[3])end;dU=dU+1 else dP[3]=Vector3.new(1,0,0)dU=4 end;if dP[3].magnitude*4>dR[3].magnitude then dU=4 end end end end;cn.Start=nil;cn.Adorn.Parent=nil;if dE then aV.CurrentParts.Parent=nil;pcall(function()game:GetService("ChangeHistoryService"):SetWaypoint("StamperMulti")end)end;return dE end;local function dY(aY)if not aY then error("Error: RbxStamper.DoStamperMouseUp: Mouse is nil")return false end;if not aY:IsA("Mouse")then error("Error: RbxStamper.DoStamperMouseUp: Mouse is of type",aY.className,"should be of type Mouse")return false end;if not aV.Dragger then error("Error: RbxStamper.DoStamperMouseUp: stampData.Dragger is nil")return false end;if not cn then return false end;local du=nil;if cf then local dZ=nil;local d_=cx()if d_ and cn and cn.Start and cn.InternalLine and cn.InternalLine.magnitude>0 then dZ=true;du=true else dZ,du=a.CanEditRegion(aV.CurrentParts,cg)end;if not dZ then if ch then ch()end;return false end end;if cr then d5()return false end;local dZ,du=a.CanEditRegion(aV.CurrentParts,cg)if not dZ then if ch then ch()end;return false end;local b1,b2=aL(aV.CurrentParts)configFound,targetCFrame=aX(aY,aV)if configFound and not cn.Adorn.Parent then if F(b1+o,b2-o)then d5()return false end;local e0=game:GetService("Workspace"):FindPartsInRegion3(Region3.new(b1+o,b2-o),aV.CurrentParts,100)for dz=1,#e0 do if aR(e0[dz])then d5()return false end end;local dA={}for dz=1,#e0 do if e0[dz].Parent and not dA[e0[dz].Parent]and e0[dz].Parent:FindFirstChild("Humanoid")and e0[dz].Parent:FindFirstChild("Humanoid"):IsA("Humanoid")then local dB=e0[dz].Parent:FindFirstChild("Torso")dA[e0[dz].Parent]=true;if dB then local cD=b2.Y+3;if aS(dB,cD,aV)then dB.CFrame=dB.CFrame+Vector3.new(0,cD-dB.CFrame.p.Y,0)else d5()return false end end end end elseif not configFound and not(cn.Start and cn.Adorn.Parent)then d4()return false end;if game:GetService("Players")["LocalPlayer"]then if game:GetService("Players").LocalPlayer["Character"]then local e1=game:GetService("Players").LocalPlayer.Character;local e2=e1:FindFirstChild("StampTracker")if e2 and not e2.Value then e2.Value=true end end end;if cn.Start and cn.Adorn.Parent and cx()then if dD(du)or du then aV.CurrentParts.Parent=nil;return true end end;cn.Start=nil;cn.Adorn.Parent=nil;local I=game:GetService("Workspace").Terrain;if cx()then local j;if aV.CurrentParts:IsA("Model")then j=I:WorldToCell(aV.CurrentParts:GetModelCFrame().p)else j=I:WorldToCell(aV.CurrentParts.CFrame.p)end;local dG=game:GetService("Workspace").Terrain.MaxExtents.Max;local dH=game:GetService("Workspace").Terrain.MaxExtents.Min;if dt(j,false)then local d3=aV.CurrentParts:FindFirstChild("ClusterMaterial",true)local dS=aV.CurrentParts:FindFirstChild("WaterForceTag",true)local dT=aV.CurrentParts:FindFirstChild("WaterForceDirectionTag",true)if j.X>=dH.X and j.Y>=dH.Y and j.Z>=dH.Z and j.X<dG.X and j.Y<dG.Y and j.Z<dG.Z then if dS then I:SetWaterCell(j.X,j.Y,j.Z,Enum.WaterForce[dS.Value],Enum.WaterDirection[dT.Value])elseif not d3 then I:SetCell(j.X,j.Y,j.Z,cw.Material,cw.clusterType,ci%4)elseif d3:IsA("Vector3Value")then I:SetCell(j.X,j.Y,j.Z,d3.Value.X,d3.Value.Y,d3.Value.Z)else I:SetCell(j.X,j.Y,j.Z,d3.Value,0,0)end;local dK=false;if aV.CurrentParts:FindFirstChild("AutoWedge")then dK=true end;if dK then game:GetService("Workspace").Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(j.x-1,j.y-1,j.z-1),Vector3int16.new(j.x+1,j.y+1,j.z+1)))end;aV.CurrentParts.Parent=nil;pcall(function()game:GetService("ChangeHistoryService"):SetWaypoint("StamperSingle")end)return true end else d5()return false end end;local function e3()if game:GetService("Players")["LocalPlayer"]then return game:GetService("Players").LocalPlayer end;return nil end;if aV.CurrentParts:IsA("Model")or aV.CurrentParts:IsA("Tool")then if aV.CurrentParts:IsA("Model")then local bF={}local bG={}bE(aV.CurrentParts,bF,bG)aV.CurrentParts:BreakJoints()aV.CurrentParts:MakeJoints()bI(bF,bG)end;local e4=aV.CurrentParts:FindFirstChild("PlayerIdTag")local e5=aV.CurrentParts:FindFirstChild("PlayerNameTag")if e4~=nil then local e6=e3()if e6~=nil then e4.Value=e6.UserId end end;if e5~=nil then if game:GetService("Players")["LocalPlayer"]then local e6=game:GetService("Players").LocalPlayer;if e6~=nil then e5.Value=e6.Name end end end;if aV.CurrentParts:FindFirstChild("RobloxModel")==nil then local c7=Instance.new("BoolValue",aV.CurrentParts)c7.Name="RobloxModel"if aV.CurrentParts:FindFirstChild("RobloxStamper")==nil then local c8=Instance.new("BoolValue",aV.CurrentParts)c8.Name="RobloxStamper"end end else aV.CurrentParts:BreakJoints()if aV.CurrentParts:FindFirstChild("RobloxStamper")==nil then local c8=Instance.new("BoolValue",aV.CurrentParts)c8.Name="RobloxStamper"end end;game:GetService("JointsService"):CreateJoinAfterMoveJoints()for q,e7 in pairs(aV.TransparencyTable)do q.Transparency=e7 end;for q,e8 in pairs(aV.ArchivableTable)do q.Archivable=e8 end;for q,e9 in pairs(aV.MaterialTable)do q.Material=e9 end;for q,ea in pairs(aV.CanCollideTable)do q.CanCollide=ea end;for q,eb in pairs(aV.AnchoredTable)do q.Anchored=eb end;for dr,e7 in pairs(aV.DecalTransparencyTable)do dr.Transparency=e7 end;for q,da in pairs(aV.SurfaceTypeTable)do d9(q,da)end;if cx()then aV.CurrentParts.Transparency=0 end;Z(aV.CurrentParts,true)aV.TransparencyTable=nil;aV.ArchivableTable=nil;aV.MaterialTable=nil;aV.CanCollideTable=nil;aV.AnchoredTable=nil;aV.SurfaceTypeTable=nil;if aV.CurrentParts:FindFirstChild("RobloxModel")==nil then local c7=Instance.new("BoolValue",aV.CurrentParts)c7.Name="RobloxModel"end;for D,dk in pairs(aV.DisabledScripts)do dk.Disabled=false end;for D,dk in pairs(aV.DisabledScripts)do local ec=dk.Parent;dk.Parent=nil;dk:Clone().Parent=ec end;aV.DisabledScripts=nil;aV.Dragger=nil;aV.CurrentParts=nil;pcall(function()game:GetService("ChangeHistoryService"):SetWaypoint("StampedObject")end)return true end;local function ed()for a1=1,#cs do cs[a1]:disconnect()cs[a1]=nil end;cs={}if aV and aV.CurrentParts then aV.CurrentParts.Parent=nil;aV.CurrentParts:Remove()end;d4()game:GetService("JointsService"):ClearJoinAfterMoveJoints()end;local function ee(aq,a5,ef)local eg={Vector3.new(1,0,0),Vector3.new(0,1,0),Vector3.new(0,0,1)}local eh=1;if ef<0 then eh=eh*-1;ef=ef*-1 end;local ei=eh*aq:vectorToWorldSpace(eg[ef])for a1=1,#a5 do local ej=a5[a1]local ek=ej.CFrame:vectorToObjectSpace(ei)if math.abs(ek.X)>math.abs(ek.Y)then if math.abs(ek.X)>math.abs(ek.Z)then if ek.X>0 then ej.RightSurface="Unjoinable"else ej.LeftSurface="Unjoinable"end else if ek.Z>0 then ej.BackSurface="Unjoinable"else ej.FrontSurface="Unjoinable"end end else if math.abs(ek.Y)>math.abs(ek.Z)then if ek.Y>0 then ej.TopSurface="Unjoinable"else ej.BottomSurface="Unjoinable"end else if ek.Z>0 then ej.BackSurface="Unjoinable"else ej.FrontSurface="Unjoinable"end end end end end;local function el()local dj,a5=dg(cb)if not dj or not a5 then return end;local em=dj:FindFirstChild("UnjoinableFaces",true)if em then for en in string.gmatch(em.Value,"[^,]*")do if tonumber(en)then if dj:IsA("Model")then ee(dj:GetModelCFrame(),a5,tonumber(en))else ee(dj.CFrame,a5,tonumber(en))end end end end;aV.ErrorBox=ck;if cf then dj.Parent=cf else dj.Parent=game:GetService("Workspace")end;if dj:FindFirstChild("ClusterMaterial",true)then local ds=dj:FindFirstChild("ClusterMaterial",true)if ds:IsA("Vector3Value")then cw.Material=ds.Value.X;cw.clusterType=ds.Value.Y;cw.clusterOrientation=ds.Value.Z elseif ds:IsA("IntValue")then cw.Material=ds.Value end end;pcall(function()cj=aY.Target end)if cj and cj.Parent:FindFirstChild("RobloxModel")==nil then game:GetService("JointsService"):SetJoinAfterMoveTarget(cj)else game:GetService("JointsService"):SetJoinAfterMoveTarget(nil)end;game:GetService("JointsService"):ShowPermissibleJoints()for D,z in pairs(aV.DisabledScripts)do if z.Name=="GhostRemovalScript"then z.Parent=aV.CurrentParts end end;aV.Dragger=Instance.new("Dragger")aV.Dragger:MouseDown(a5[1],Vector3.new(0,0,0),a5)aV.Dragger:MouseUp()cN(aY)table.insert(cs,aY.Move:connect(function()if cp or cq then return end;cp=true;cN(aY)cp=false end))table.insert(cs,aY.Button1Down:connect(function()d6(aY)end))table.insert(cs,aY.Button1Up:connect(function()cq=true;while cp do wait()end;cu.Value=dY(aY)d4()cq=false end))cu.Value=false end;local function eo(ep)if ep then if not ep:IsA("Model")and not ep:IsA("BasePart")then error("resetStamperState: newModelToStamp (first arg) is not nil, but not a model or part!")end;cb=ep end;ed()el()end;eo()co.Stamped=cu;co.Paused=false;co.LoadNewModel=function(eq)if eq and not eq:IsA("Model")and not eq:IsA("BasePart")then error("Control.LoadNewModel: newStampModel (first arg) is not a Model or Part!")return nil end;eo(eq)end;co.ReloadModel=function()eo()end;co.Pause=function()if not co.Paused then ed()co.Paused=true else print("RbxStamper Warning: Tried to call Control.Pause() when already paused")end end;co.Resume=function()if co.Paused then el()co.Paused=false else print("RbxStamper Warning: Tried to call Control.Resume() without Pausing First")end end;co.ResetRotation=function()end;co.Destroy=function()for a1=1,#cs do cs[a1]:disconnect()cs[a1]=nil end;if ct then ct:disconnect()end;game:GetService("JointsService"):ClearJoinAfterMoveJoints()if cm then cm:Destroy()end;if cl then cl:Destroy()end;if ck then ck:Destroy()end;if aV then if aV["Dragger"]then aV.Dragger:Destroy()end;if aV.CurrentParts then aV.CurrentParts:Destroy()end end;if co and co["Stamped"]then co.Stamped:Destroy()end;co=nil end;return co end;a.Help=function(er)if er=="GetStampModel"or er==a.GetStampModel then return"Function GetStampModel.  Arguments: assetId, useAssetVersionId.  assetId is the asset to load in, define useAssetVersionId as true if assetId is a version id instead of a relative assetId.  Side effect: returns a model of the assetId, or a string with error message if something fails"end;if er=="SetupStamperDragger"or er==a.SetupStamperDragger then return"Function SetupStamperDragger. Side Effect: Creates 4x4 stamping mechanism for building out parts quickly. Arguments: ModelToStamp, Mouse, LegalStampCheckFunction. ModelToStamp should be a Model or Part, preferrably loaded from RbxStamper.GetStampModel and should have extents that are multiples of 4.  Mouse should be a mouse object (obtained from things such as Tool.OnEquipped), used to drag parts around 'stamp' them out. LegalStampCheckFunction is optional, used as a callback with a table argument (table is full of instances about to be stamped). Function should return either true or false, false stopping the stamp action."end end;return a
